{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) : typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) : factory(global.reactAccessibleAccordion = {}, global.React);\n})(this, function (exports, React) {\n  'use strict';\n\n  var React__default = 'default' in React ? React['default'] : React;\n\n  function unwrapExports(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n  }\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * \n   */\n\n\n  function makeEmptyFunction(arg) {\n    return function () {\n      return arg;\n    };\n  }\n  /**\n   * This function accepts and discards inputs; it has no side effects. This is\n   * primarily useful idiomatically for overridable function endpoints which\n   * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n   */\n\n\n  var emptyFunction = function emptyFunction() {};\n\n  emptyFunction.thatReturns = makeEmptyFunction;\n  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n  emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n\n  emptyFunction.thatReturnsThis = function () {\n    return this;\n  };\n\n  emptyFunction.thatReturnsArgument = function (arg) {\n    return arg;\n  };\n\n  var emptyFunction_1 = emptyFunction;\n  var emptyFunction$1 =\n  /*#__PURE__*/\n  Object.freeze({\n    default: emptyFunction_1,\n    __moduleExports: emptyFunction_1\n  });\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   */\n\n  /**\n   * Use invariant() to assert state which your program assumes to be true.\n   *\n   * Provide sprintf-style format (only %s is supported) and arguments\n   * to provide information about what broke and what you were\n   * expecting.\n   *\n   * The invariant message will be stripped in production, but the invariant\n   * will remain to ensure logic does not differ in production.\n   */\n\n  var validateFormat = function validateFormat(format) {};\n\n  function invariant(condition, format, a, b, c, d, e, f) {\n    validateFormat(format);\n\n    if (!condition) {\n      var error;\n\n      if (format === undefined) {\n        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n      } else {\n        var args = [a, b, c, d, e, f];\n        var argIndex = 0;\n        error = new Error(format.replace(/%s/g, function () {\n          return args[argIndex++];\n        }));\n        error.name = 'Invariant Violation';\n      }\n\n      error.framesToPop = 1; // we don't care about invariant's own frame\n\n      throw error;\n    }\n  }\n\n  var invariant_1 = invariant;\n  var invariant$1 =\n  /*#__PURE__*/\n  Object.freeze({\n    default: invariant_1,\n    __moduleExports: invariant_1\n  });\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n  var ReactPropTypesSecret_1 = ReactPropTypesSecret;\n  var ReactPropTypesSecret$1 =\n  /*#__PURE__*/\n  Object.freeze({\n    default: ReactPropTypesSecret_1,\n    __moduleExports: ReactPropTypesSecret_1\n  });\n  var emptyFunction$2 = emptyFunction$1 && emptyFunction_1 || emptyFunction$1;\n  var invariant$2 = invariant$1 && invariant_1 || invariant$1;\n  var ReactPropTypesSecret$2 = ReactPropTypesSecret$1 && ReactPropTypesSecret_1 || ReactPropTypesSecret$1;\n\n  var factoryWithThrowingShims = function factoryWithThrowingShims() {\n    function shim(props, propName, componentName, location, propFullName, secret) {\n      if (secret === ReactPropTypesSecret$2) {\n        // It is still safe when called from React.\n        return;\n      }\n\n      invariant$2(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');\n    }\n\n    shim.isRequired = shim;\n\n    function getShim() {\n      return shim;\n    } // Important!\n    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n\n\n    var ReactPropTypes = {\n      array: shim,\n      bool: shim,\n      func: shim,\n      number: shim,\n      object: shim,\n      string: shim,\n      symbol: shim,\n      any: shim,\n      arrayOf: getShim,\n      element: shim,\n      instanceOf: getShim,\n      node: shim,\n      objectOf: getShim,\n      oneOf: getShim,\n      oneOfType: getShim,\n      shape: getShim,\n      exact: getShim\n    };\n    ReactPropTypes.checkPropTypes = emptyFunction$2;\n    ReactPropTypes.PropTypes = ReactPropTypes;\n    return ReactPropTypes;\n  };\n\n  var factoryWithThrowingShims$1 =\n  /*#__PURE__*/\n  Object.freeze({\n    default: factoryWithThrowingShims,\n    __moduleExports: factoryWithThrowingShims\n  });\n  var require$$0 = factoryWithThrowingShims$1 && factoryWithThrowingShims || factoryWithThrowingShims$1;\n  var propTypes = createCommonjsModule(function (module) {\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     */\n    {\n      // By explicitly using `prop-types` you are opting into new production behavior.\n      // http://fb.me/prop-types-in-prod\n      module.exports = require$$0();\n    }\n  });\n  var propTypes$1 =\n  /*#__PURE__*/\n  Object.freeze({\n    default: propTypes,\n    __moduleExports: propTypes\n  });\n\n  var _propTypes = propTypes$1 && propTypes || propTypes$1;\n\n  var lib = createCommonjsModule(function (module, exports) {\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    exports.__esModule = true;\n\n    var _react2 = _interopRequireDefault(React__default);\n\n    var _propTypes2 = _interopRequireDefault(_propTypes);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    function _possibleConstructorReturn(self, call) {\n      if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n\n      return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));\n      }\n\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    function createEventEmitter(value) {\n      var handlers = [];\n      return {\n        on: function on(handler) {\n          handlers.push(handler);\n        },\n        off: function off(handler) {\n          handlers = handlers.filter(function (h) {\n            return h !== handler;\n          });\n        },\n        get: function get() {\n          return value;\n        },\n        set: function set(newValue) {\n          value = newValue;\n          handlers.forEach(function (handler) {\n            return handler(value);\n          });\n        }\n      };\n    }\n\n    function onlyChild(children) {\n      return Array.isArray(children) ? children[0] : children;\n    }\n\n    var uniqueId = 0;\n\n    function createReactContext(defaultValue) {\n      var _Provider$childContex, _Consumer$contextType;\n\n      var contextProp = '__create-react-context-' + uniqueId++ + '__';\n\n      var Provider = function (_Component) {\n        _inherits(Provider, _Component);\n\n        function Provider() {\n          var _temp, _this, _ret;\n\n          _classCallCheck(this, Provider);\n\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp), _possibleConstructorReturn(_this, _ret);\n        }\n\n        Provider.prototype.getChildContext = function getChildContext() {\n          var _ref;\n\n          return _ref = {}, _ref[contextProp] = this.emitter, _ref;\n        };\n\n        Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n          if (this.props.value !== nextProps.value) {\n            this.emitter.set(nextProps.value);\n          }\n        };\n\n        Provider.prototype.render = function render() {\n          return this.props.children;\n        };\n\n        return Provider;\n      }(React__default.Component);\n\n      Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes2.default.object.isRequired, _Provider$childContex);\n\n      var Consumer = function (_Component2) {\n        _inherits(Consumer, _Component2);\n\n        function Consumer() {\n          var _temp2, _this2, _ret2;\n\n          _classCallCheck(this, Consumer);\n\n          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {\n            value: _this2.getValue()\n          }, _this2.onUpdate = function () {\n            _this2.setState({\n              value: _this2.getValue()\n            });\n          }, _temp2), _possibleConstructorReturn(_this2, _ret2);\n        }\n\n        Consumer.prototype.componentDidMount = function componentDidMount() {\n          if (this.context[contextProp]) {\n            this.context[contextProp].on(this.onUpdate);\n          }\n        };\n\n        Consumer.prototype.componentWillUnmount = function componentWillUnmount() {\n          if (this.context[contextProp]) {\n            this.context[contextProp].off(this.onUpdate);\n          }\n        };\n\n        Consumer.prototype.getValue = function getValue() {\n          if (this.context[contextProp]) {\n            return this.context[contextProp].get();\n          } else {\n            return defaultValue;\n          }\n        };\n\n        Consumer.prototype.render = function render() {\n          return onlyChild(this.props.children)(this.state.value);\n        };\n\n        return Consumer;\n      }(React__default.Component);\n\n      Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes2.default.object, _Consumer$contextType);\n      return {\n        Provider: Provider,\n        Consumer: Consumer\n      };\n    }\n\n    exports.default = createReactContext;\n    module.exports = exports['default'];\n  });\n  var createReactContext = unwrapExports(lib);\n\n  var _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n  };\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var StateContext = createReactContext(null);\n\n  var Container = function () {\n    function Container() {\n      var _this = this;\n\n      _classCallCheck(this, Container);\n\n      this._listeners = [];\n      CONTAINER_DEBUG_CALLBACKS.forEach(function (cb) {\n        return cb(_this);\n      });\n    }\n\n    Container.prototype.setState = function setState(updater, callback) {\n      var _this2 = this;\n\n      return Promise.resolve().then(function () {\n        var nextState = void 0;\n\n        if (typeof updater === 'function') {\n          nextState = updater(_this2.state);\n        } else {\n          nextState = updater;\n        }\n\n        if (nextState == null) {\n          if (callback) callback();\n          return;\n        }\n\n        _this2.state = Object.assign({}, _this2.state, nextState);\n\n        var promises = _this2._listeners.map(function (listener) {\n          return listener();\n        });\n\n        return Promise.all(promises).then(function () {\n          if (callback) {\n            return callback();\n          }\n        });\n      });\n    };\n\n    Container.prototype.subscribe = function subscribe(fn) {\n      this._listeners.push(fn);\n    };\n\n    Container.prototype.unsubscribe = function unsubscribe(fn) {\n      this._listeners = this._listeners.filter(function (f) {\n        return f !== fn;\n      });\n    };\n\n    return Container;\n  }();\n\n  var DUMMY_STATE = {};\n\n  var Subscribe = function (_React$Component) {\n    _inherits(Subscribe, _React$Component);\n\n    function Subscribe() {\n      var _temp, _this3, _ret;\n\n      _classCallCheck(this, Subscribe);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this3 = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this3), _this3.state = {}, _this3.instances = [], _this3.unmounted = false, _this3.onUpdate = function () {\n        return new Promise(function (resolve) {\n          if (!_this3.unmounted) {\n            _this3.setState(DUMMY_STATE, resolve);\n          } else {\n            resolve();\n          }\n        });\n      }, _temp), _possibleConstructorReturn(_this3, _ret);\n    }\n\n    Subscribe.prototype.componentWillUnmount = function componentWillUnmount() {\n      this.unmounted = true;\n\n      this._unsubscribe();\n    };\n\n    Subscribe.prototype._unsubscribe = function _unsubscribe() {\n      var _this4 = this;\n\n      this.instances.forEach(function (container) {\n        container.unsubscribe(_this4.onUpdate);\n      });\n    };\n\n    Subscribe.prototype._createInstances = function _createInstances(map, containers) {\n      var _this5 = this;\n\n      this._unsubscribe();\n\n      if (map === null) {\n        throw new Error('You must wrap your <Subscribe> components with a <Provider>');\n      }\n\n      var safeMap = map;\n      var instances = containers.map(function (ContainerItem) {\n        var instance = void 0;\n\n        if ((typeof ContainerItem === 'undefined' ? 'undefined' : _typeof(ContainerItem)) === 'object' && ContainerItem instanceof Container) {\n          instance = ContainerItem;\n        } else {\n          instance = safeMap.get(ContainerItem);\n\n          if (!instance) {\n            instance = new ContainerItem();\n            safeMap.set(ContainerItem, instance);\n          }\n        }\n\n        instance.unsubscribe(_this5.onUpdate);\n        instance.subscribe(_this5.onUpdate);\n        return instance;\n      });\n      this.instances = instances;\n      return instances;\n    };\n\n    Subscribe.prototype.render = function render() {\n      var _this6 = this;\n\n      return React__default.createElement(StateContext.Consumer, null, function (map) {\n        return _this6.props.children.apply(null, _this6._createInstances(map, _this6.props.to));\n      });\n    };\n\n    return Subscribe;\n  }(React__default.Component);\n\n  function Provider(props) {\n    return React__default.createElement(StateContext.Consumer, null, function (parentMap) {\n      var childMap = new Map(parentMap);\n\n      if (props.inject) {\n        props.inject.forEach(function (instance) {\n          childMap.set(instance.constructor, instance);\n        });\n      }\n\n      return React__default.createElement(StateContext.Provider, {\n        value: childMap\n      }, props.children);\n    });\n  }\n\n  var CONTAINER_DEBUG_CALLBACKS = [];\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  function _toConsumableArray(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  }\n\n  function _classCallCheck$1(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _possibleConstructorReturn$1(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits$1(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var AccordionContainer = function (_Container) {\n    _inherits$1(AccordionContainer, _Container);\n\n    function AccordionContainer() {\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck$1(this, AccordionContainer);\n\n      var _this = _possibleConstructorReturn$1(this, (AccordionContainer.__proto__ || Object.getPrototypeOf(AccordionContainer)).call(this));\n\n      _this.setAccordion = function (accordion) {\n        if (accordion !== _this.state.accordion) {\n          return _this.setState({\n            accordion: accordion\n          });\n        }\n\n        return null;\n      };\n\n      _this.setOnChange = function (onChange) {\n        if (onChange !== _this.state.onChange) {\n          return _this.setState({\n            onChange: onChange\n          });\n        }\n\n        return null;\n      };\n\n      _this.addItem = function (newItem) {\n        // Need to use callback style otherwise race-conditions are created by concurrent registrations.\n        _this.setState(function (state) {\n          var items = void 0;\n\n          if (state.items.some(function (item) {\n            return item.uuid === newItem.uuid;\n          })) {\n            // eslint-disable-next-line no-console\n            console.error('AccordionItem error: One item already has the uuid \"' + newItem.uuid + '\". Uuid property must be unique. See: https://github.com/springload/react-accessible-accordion#accordionitem');\n          }\n\n          if (state.accordion && newItem.expanded) {\n            // If this is a true accordion and the new item is expanded, then the others must be closed.\n            items = [].concat(_toConsumableArray(state.items.map(function (item) {\n              return _extends({}, item, {\n                expanded: false\n              });\n            })), [newItem]);\n          } else {\n            items = [].concat(_toConsumableArray(state.items), [newItem]);\n          }\n\n          return {\n            items: items\n          };\n        });\n      };\n\n      _this.removeItem = function (key) {\n        return _this.setState(function (state) {\n          return {\n            items: state.items.filter(function (item) {\n              return item.uuid !== key;\n            })\n          };\n        });\n      };\n\n      _this.setExpanded = function (key, expanded) {\n        return _this.setState(function (state) {\n          return {\n            items: state.items.map(function (item) {\n              if (item.uuid === key) {\n                return _extends({}, item, {\n                  expanded: expanded\n                });\n              }\n\n              if (state.accordion && expanded) {\n                // If this is an accordion, we might need to collapse the other expanded item.\n                return _extends({}, item, {\n                  expanded: false\n                });\n              }\n\n              return item;\n            })\n          };\n        }).then(function () {\n          if (_this.state.accordion) {\n            _this.state.onChange(key);\n          } else {\n            _this.state.onChange(_this.state.items.filter(function (item) {\n              return item.expanded;\n            }).map(function (item) {\n              return item.uuid;\n            }));\n          }\n        });\n      };\n\n      _this.state = _extends({\n        items: [],\n        accordion: true,\n        onChange: function onChange() {}\n      }, args);\n      return _this;\n    }\n\n    return AccordionContainer;\n  }(Container);\n\n  var _extends$1 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  function _objectWithoutProperties(obj, keys) {\n    var target = {};\n\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n\n    return target;\n  }\n\n  var accordionDefaultProps = {\n    accordion: true\n  };\n\n  var Accordion = function Accordion(_ref) {\n    var accordion = _ref.accordion,\n        rest = _objectWithoutProperties(_ref, ['accordion']);\n\n    return React__default.createElement('div', _extends$1({\n      role: accordion ? 'tablist' : null\n    }, rest));\n  };\n\n  Accordion.defaultProps = accordionDefaultProps;\n\n  var _extends$2 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _objectWithoutProperties$1(obj, keys) {\n    var target = {};\n\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n\n    return target;\n  }\n\n  function _classCallCheck$2(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _possibleConstructorReturn$2(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits$2(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var defaultProps = {\n    accordion: true,\n    onChange: function onChange() {},\n    className: 'accordion',\n    children: null\n  };\n\n  var AccordionWrapper = function (_Component) {\n    _inherits$2(AccordionWrapper, _Component);\n\n    function AccordionWrapper() {\n      var _ref;\n\n      var _temp, _this, _ret;\n\n      _classCallCheck$2(this, AccordionWrapper);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = _possibleConstructorReturn$2(this, (_ref = AccordionWrapper.__proto__ || Object.getPrototypeOf(AccordionWrapper)).call.apply(_ref, [this].concat(args))), _this), _this.accordionStore = new AccordionContainer({\n        accordion: _this.props.accordion,\n        onChange: _this.props.onChange\n      }), _this.renderAccordion = function (accordionStore) {\n        var _this$props = _this.props,\n            accordion = _this$props.accordion,\n            onChange = _this$props.onChange,\n            rest = _objectWithoutProperties$1(_this$props, ['accordion', 'onChange']);\n\n        return React__default.createElement(Accordion, _extends$2({\n          accordion: accordionStore.state.accordion\n        }, rest));\n      }, _temp), _possibleConstructorReturn$2(_this, _ret);\n    }\n\n    _createClass(AccordionWrapper, [{\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        this.accordionStore.setAccordion(this.props.accordion);\n        this.accordionStore.setOnChange(this.props.onChange);\n      }\n    }, {\n      key: 'componentDidUpdate',\n      value: function componentDidUpdate() {\n        this.accordionStore.setAccordion(this.props.accordion);\n        this.accordionStore.setOnChange(this.props.onChange);\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        return React__default.createElement(Provider, {\n          inject: [this.accordionStore]\n        }, React__default.createElement(Subscribe, {\n          to: [AccordionContainer]\n        }, this.renderAccordion));\n      }\n    }]);\n\n    return AccordionWrapper;\n  }(React.Component);\n\n  AccordionWrapper.defaultProps = defaultProps;\n  /*!\n   * consecutive\n   * Get consecutive numbers\n   * Copyright(c) 2017 ivanoff .$ curl -A cv ivanoff.org.ua\n   * MIT Licensed\n   */\n\n  var consecutive = function consecutive(begin, base, inc) {\n    var number = begin || 0;\n    if (typeof base !== 'number') base = 10;\n    if (typeof inc !== 'number') inc = 1;\n    return function () {\n      var res;\n\n      if (typeof base === 'undefined' || base === 10) {\n        res = number;\n        number += inc;\n      } else {\n        res = number.toString();\n        number = (parseInt(number, base) + inc).toString(base);\n      }\n\n      return res;\n    };\n  };\n\n  var _extends$3 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var _createClass$1 = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _classCallCheck$3(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _possibleConstructorReturn$3(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits$3(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var nextUuid = consecutive();\n\n  function resetNextUuid() {\n    nextUuid = consecutive();\n  }\n\n  var ItemContainer = function (_Container) {\n    _inherits$3(ItemContainer, _Container);\n\n    function ItemContainer() {\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck$3(this, ItemContainer);\n\n      var _this = _possibleConstructorReturn$3(this, (ItemContainer.__proto__ || Object.getPrototypeOf(ItemContainer)).call(this));\n\n      _this.state = _extends$3({}, args);\n\n      if (_this.state.uuid === undefined) {\n        _this.state.uuid = nextUuid();\n      }\n\n      return _this;\n    }\n\n    _createClass$1(ItemContainer, [{\n      key: 'setUuid',\n      value: function setUuid(customUuid) {\n        return this.setState({\n          uuid: customUuid\n        });\n      }\n    }]);\n\n    return ItemContainer;\n  }(Container);\n\n  var classnames = createCommonjsModule(function (module) {\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n    /*!\n      Copyright (c) 2016 Jed Watson.\n      Licensed under the MIT License (MIT), see\n      http://jedwatson.github.io/classnames\n    */\n\n    /* global define */\n\n\n    (function () {\n      var hasOwn = {}.hasOwnProperty;\n\n      function classNames() {\n        var classes = [];\n\n        for (var i = 0; i < arguments.length; i++) {\n          var arg = arguments[i];\n          if (!arg) continue;\n          var argType = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);\n\n          if (argType === 'string' || argType === 'number') {\n            classes.push(arg);\n          } else if (Array.isArray(arg)) {\n            classes.push(classNames.apply(null, arg));\n          } else if (argType === 'object') {\n            for (var key in arg) {\n              if (hasOwn.call(arg, key) && arg[key]) {\n                classes.push(key);\n              }\n            }\n          }\n        }\n\n        return classes.join(' ');\n      }\n\n      if (module.exports) {\n        module.exports = classNames;\n      } else if (typeof undefined === 'function' && _typeof(undefined.amd) === 'object' && undefined.amd) {\n        // register as 'classnames', consistent with npm package name\n        undefined('classnames', [], function () {\n          return classNames;\n        });\n      } else {\n        window.classNames = classNames;\n      }\n    })();\n  });\n\n  var _extends$4 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var _createClass$2 = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _objectWithoutProperties$2(obj, keys) {\n    var target = {};\n\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n\n    return target;\n  }\n\n  function _classCallCheck$4(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _possibleConstructorReturn$4(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits$4(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var AccordionItem = function (_Component) {\n    _inherits$4(AccordionItem, _Component);\n\n    function AccordionItem() {\n      _classCallCheck$4(this, AccordionItem);\n\n      return _possibleConstructorReturn$4(this, (AccordionItem.__proto__ || Object.getPrototypeOf(AccordionItem)).apply(this, arguments));\n    }\n\n    _createClass$2(AccordionItem, [{\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        var _props = this.props,\n            uuid = _props.uuid,\n            accordionStore = _props.accordionStore,\n            disabled = _props.disabled;\n        accordionStore.addItem({\n          uuid: uuid,\n          expanded: this.props.expanded || false,\n          disabled: disabled\n        });\n      }\n    }, {\n      key: 'componentWillUnmount',\n      value: function componentWillUnmount() {\n        this.props.accordionStore.removeItem(this.props.uuid);\n      } // This is here so that the user can dynamically set the 'expanded' state using the 'expanded' prop.\n\n    }, {\n      key: 'componentDidUpdate',\n      value: function componentDidUpdate(prevProps) {\n        var _props2 = this.props,\n            uuid = _props2.uuid,\n            expanded = _props2.expanded,\n            accordionStore = _props2.accordionStore;\n\n        if (expanded !== prevProps.expanded) {\n          accordionStore.setExpanded(uuid, expanded);\n        }\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var _props3 = this.props,\n            uuid = _props3.uuid,\n            className = _props3.className,\n            hideBodyClassName = _props3.hideBodyClassName,\n            accordionStore = _props3.accordionStore,\n            disabled = _props3.disabled,\n            expanded = _props3.expanded,\n            rest = _objectWithoutProperties$2(_props3, ['uuid', 'className', 'hideBodyClassName', 'accordionStore', 'disabled', 'expanded']);\n\n        var currentItem = accordionStore.state.items.filter(function (item) {\n          return item.uuid === uuid;\n        })[0];\n\n        if (!currentItem) {\n          return null;\n        }\n\n        return React__default.createElement('div', _extends$4({\n          className: classnames(className, _defineProperty({}, hideBodyClassName, !currentItem.expanded && hideBodyClassName))\n        }, rest));\n      }\n    }]);\n\n    return AccordionItem;\n  }(React.Component);\n\n  var _extends$5 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var _createClass$3 = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _classCallCheck$5(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _possibleConstructorReturn$5(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits$5(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var defaultProps$1 = {\n    className: 'accordion__item',\n    hideBodyClassName: '',\n    disabled: false,\n    expanded: false,\n    accordionStore: new AccordionContainer(),\n    uuid: undefined\n  };\n\n  var AccordionItemWrapper = function (_Component) {\n    _inherits$5(AccordionItemWrapper, _Component);\n\n    function AccordionItemWrapper() {\n      var _ref;\n\n      var _temp, _this, _ret;\n\n      _classCallCheck$5(this, AccordionItemWrapper);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = _possibleConstructorReturn$5(this, (_ref = AccordionItemWrapper.__proto__ || Object.getPrototypeOf(AccordionItemWrapper)).call.apply(_ref, [this].concat(args))), _this), _this.itemContainer = new ItemContainer({\n        uuid: _this.props.uuid\n      }), _this.renderItem = function (accordionStore, itemStore) {\n        var uuid = itemStore.state.uuid;\n        return React__default.createElement(AccordionItem, _extends$5({}, _this.props, {\n          uuid: uuid,\n          accordionStore: accordionStore\n        }));\n      }, _temp), _possibleConstructorReturn$5(_this, _ret);\n    }\n\n    _createClass$3(AccordionItemWrapper, [{\n      key: 'render',\n      value: function render() {\n        return React__default.createElement(Provider, {\n          inject: [this.itemContainer]\n        }, React__default.createElement(Subscribe, {\n          to: [AccordionContainer, ItemContainer]\n        }, this.renderItem));\n      }\n    }]);\n\n    return AccordionItemWrapper;\n  }(React.Component);\n\n  AccordionItemWrapper.defaultProps = defaultProps$1;\n\n  var _extends$6 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var _createClass$4 = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _defineProperty$1(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _objectWithoutProperties$3(obj, keys) {\n    var target = {};\n\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n\n    return target;\n  }\n\n  function _classCallCheck$6(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _possibleConstructorReturn$6(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits$6(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var AccordionItemTitle = function (_Component) {\n    _inherits$6(AccordionItemTitle, _Component);\n\n    function AccordionItemTitle() {\n      var _ref;\n\n      var _temp, _this, _ret;\n\n      _classCallCheck$6(this, AccordionItemTitle);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = _possibleConstructorReturn$6(this, (_ref = AccordionItemTitle.__proto__ || Object.getPrototypeOf(AccordionItemTitle)).call.apply(_ref, [this].concat(args))), _this), _this.handleClick = function () {\n        var _this$props = _this.props,\n            uuid = _this$props.uuid,\n            expanded = _this$props.expanded,\n            setExpanded = _this$props.setExpanded;\n        setExpanded(uuid, !expanded);\n      }, _this.handleKeyPress = function (evt) {\n        if (evt.charCode === 13 || evt.charCode === 32) {\n          evt.preventDefault();\n\n          _this.handleClick();\n        }\n      }, _temp), _possibleConstructorReturn$6(_this, _ret);\n    }\n\n    _createClass$4(AccordionItemTitle, [{\n      key: 'render',\n      value: function render() {\n        var _props = this.props,\n            className = _props.className,\n            hideBodyClassName = _props.hideBodyClassName,\n            accordionStore = _props.accordionStore,\n            item = _props.item,\n            accordion = _props.accordion,\n            setExpanded = _props.setExpanded,\n            expanded = _props.expanded,\n            uuid = _props.uuid,\n            disabled = _props.disabled,\n            rest = _objectWithoutProperties$3(_props, ['className', 'hideBodyClassName', 'accordionStore', 'item', 'accordion', 'setExpanded', 'expanded', 'uuid', 'disabled']);\n\n        var id = 'accordion__title-' + uuid;\n        var ariaControls = 'accordion__body-' + uuid;\n        var role = accordion ? 'tab' : 'button';\n        var titleClassName = classnames(className, _defineProperty$1({}, hideBodyClassName, hideBodyClassName && !expanded));\n\n        if (role === 'tab') {\n          return React__default.createElement('div', _extends$6({\n            id: id,\n            'aria-selected': expanded,\n            'aria-controls': ariaControls,\n            className: titleClassName,\n            onClick: disabled ? undefined : this.handleClick,\n            role: role,\n            tabIndex: '0' // eslint-disable-line jsx-a11y/no-noninteractive-tabindex\n            ,\n            onKeyPress: this.handleKeyPress,\n            disabled: disabled\n          }, rest));\n        }\n\n        return React__default.createElement('div', _extends$6({\n          id: id,\n          'aria-expanded': expanded,\n          'aria-controls': ariaControls,\n          className: titleClassName,\n          onClick: disabled ? undefined : this.handleClick,\n          role: role,\n          tabIndex: '0' // eslint-disable-line jsx-a11y/no-noninteractive-tabindex\n          ,\n          onKeyPress: this.handleKeyPress,\n          disabled: disabled\n        }, rest));\n      }\n    }]);\n\n    return AccordionItemTitle;\n  }(React.Component);\n\n  AccordionItemTitle.accordionElementName = 'AccordionItemTitle';\n\n  var _extends$7 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var _createClass$5 = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _classCallCheck$7(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _possibleConstructorReturn$7(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits$7(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var AccordionItemTitleWrapper = function (_Component) {\n    _inherits$7(AccordionItemTitleWrapper, _Component);\n\n    function AccordionItemTitleWrapper() {\n      var _ref;\n\n      var _temp, _this, _ret;\n\n      _classCallCheck$7(this, AccordionItemTitleWrapper);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = _possibleConstructorReturn$7(this, (_ref = AccordionItemTitleWrapper.__proto__ || Object.getPrototypeOf(AccordionItemTitleWrapper)).call.apply(_ref, [this].concat(args))), _this), _this.renderItemTitle = function (accordionStore, itemStore) {\n        var uuid = itemStore.state.uuid;\n        var _accordionStore$state = accordionStore.state,\n            items = _accordionStore$state.items,\n            accordion = _accordionStore$state.accordion;\n        var item = items.filter(function (stateItem) {\n          return stateItem.uuid === uuid;\n        })[0];\n        return React__default.createElement(AccordionItemTitle, _extends$7({}, _this.props, item, {\n          setExpanded: accordionStore.setExpanded,\n          accordion: accordion\n        }));\n      }, _temp), _possibleConstructorReturn$7(_this, _ret);\n    }\n\n    _createClass$5(AccordionItemTitleWrapper, [{\n      key: 'render',\n      value: function render() {\n        return React__default.createElement(Subscribe, {\n          to: [AccordionContainer, ItemContainer]\n        }, this.renderItemTitle);\n      }\n    }]);\n\n    return AccordionItemTitleWrapper;\n  }(React.Component);\n\n  AccordionItemTitleWrapper.defaultProps = {\n    className: 'accordion__title',\n    hideBodyClassName: ''\n  };\n\n  var _extends$8 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  function _defineProperty$2(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _objectWithoutProperties$4(obj, keys) {\n    var target = {};\n\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n\n    return target;\n  }\n\n  var AccordionItemBody = function AccordionItemBody(props) {\n    var className = props.className,\n        hideBodyClassName = props.hideBodyClassName,\n        uuid = props.uuid,\n        expanded = props.expanded,\n        disabled = props.disabled,\n        accordion = props.accordion,\n        rest = _objectWithoutProperties$4(props, ['className', 'hideBodyClassName', 'uuid', 'expanded', 'disabled', 'accordion']);\n\n    return React__default.createElement('div', _extends$8({\n      id: 'accordion__body-' + uuid,\n      className: classnames(className, _defineProperty$2({}, hideBodyClassName, !expanded)),\n      'aria-hidden': !expanded,\n      'aria-labelledby': 'accordion__title-' + uuid,\n      role: accordion ? 'tabpanel' : null\n    }, rest));\n  };\n\n  var _extends$9 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var _createClass$6 = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _classCallCheck$8(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _possibleConstructorReturn$8(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits$8(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var AccordionItemBodyWrapper = function (_Component) {\n    _inherits$8(AccordionItemBodyWrapper, _Component);\n\n    function AccordionItemBodyWrapper() {\n      var _ref;\n\n      var _temp, _this, _ret;\n\n      _classCallCheck$8(this, AccordionItemBodyWrapper);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = _possibleConstructorReturn$8(this, (_ref = AccordionItemBodyWrapper.__proto__ || Object.getPrototypeOf(AccordionItemBodyWrapper)).call.apply(_ref, [this].concat(args))), _this), _this.renderItemBody = function (accordionStore, itemStore) {\n        var uuid = itemStore.state.uuid;\n        var _accordionStore$state = accordionStore.state,\n            items = _accordionStore$state.items,\n            accordion = _accordionStore$state.accordion;\n        var item = items.filter(function (stateItem) {\n          return stateItem.uuid === uuid;\n        })[0];\n        return React__default.createElement(AccordionItemBody, _extends$9({}, _this.props, item, {\n          accordion: accordion\n        }));\n      }, _temp), _possibleConstructorReturn$8(_this, _ret);\n    }\n\n    _createClass$6(AccordionItemBodyWrapper, [{\n      key: 'render',\n      value: function render() {\n        return React__default.createElement(Subscribe, {\n          to: [AccordionContainer, ItemContainer]\n        }, this.renderItemBody);\n      }\n    }]);\n\n    return AccordionItemBodyWrapper;\n  }(React.Component);\n\n  AccordionItemBodyWrapper.defaultProps = {\n    className: 'accordion__body',\n    hideBodyClassName: 'accordion__body--hidden'\n  };\n  exports.Accordion = AccordionWrapper;\n  exports.AccordionItem = AccordionItemWrapper;\n  exports.AccordionItemTitle = AccordionItemTitleWrapper;\n  exports.AccordionItemBody = AccordionItemBodyWrapper;\n  exports.resetNextUuid = resetNextUuid;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}